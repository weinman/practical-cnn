<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Andrea Vedaldi and Andrew Zisserman" />
  <title>Convolutional Neural Networks Practical</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../../2019S/courseweb/labs/lab.css" />
  <link rel="stylesheet" href="instructions.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Convolutional Neural Networks Practical</h1>
<p class="author">Andrea Vedaldi and Andrew Zisserman</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#preparation">Preparation</a></li>
<li><a href="#part1">Part 1: CNN building blocks</a><ul>
<li><a href="#part1.1">Part 1.1: convolution</a></li>
<li><a href="#part1.2">Part 1.2: non-linear activation functions</a></li>
<li><a href="#part1.3">Part 1.3: pooling</a></li>
<li><a href="#part1.4">Part 1.4: normalisation</a></li>
</ul></li>
<li><a href="#part-2-back-propagation-and-derivatives">Part 2: back-propagation and derivatives</a><ul>
<li><a href="#part-2.1-the-theory-of-back-propagation">Part 2.1: the theory of back-propagation</a></li>
<li><a href="#part-2.1-using-back-propagation-in-practice">Part 2.1: using back-propagation in practice</a></li>
</ul></li>
<li><a href="#part-3-learning-a-tiny-cnn">Part 3: learning a tiny CNN</a><ul>
<li><a href="#part-3.1-training-data-and-labels">Part 3.1: training data and labels</a></li>
<li><a href="#part-3.2-image-preprocessing">Part 3.2: image preprocessing</a></li>
<li><a href="#part-3.3-learning-with-gradient-descent">Part 3.3: learning with gradient descent</a></li>
<li><a href="#part-3.4-experimenting-with-the-tiny-cnn">Part 3.4: experimenting with the tiny CNN</a></li>
</ul></li>
<li><a href="#part-4-learning-a-character-cnn">Part 4: learning a character CNN</a><ul>
<li><a href="#part-4.1-prepare-the-data">Part 4.1: prepare the data</a></li>
<li><a href="#part-4.2-intialize-a-cnn-architecture">Part 4.2: intialize a CNN architecture</a></li>
<li><a href="#part-4.3-train-and-evaluate-the-cnn">Part 4.3: train and evaluate the CNN</a></li>
<li><a href="#part-4.4-visualise-the-learned-filters">Part 4.4: visualise the learned filters</a></li>
<li><a href="#part-4.5-apply-the-model">Part 4.5: apply the model</a></li>
<li><a href="#part-4.6-training-with-jitter">Part 4.6: training with jitter</a></li>
<li><a href="#part-4.7-training-using-the-gpu">Part 4.7: Training using the GPU</a></li>
</ul></li>
<li><a href="#part-5-using-pretrained-models">Part 5: using pretrained models</a><ul>
<li><a href="#part-5.1-load-a-pre-trained-model">Part 5.1: load a pre-trained model</a></li>
<li><a href="#part-5.2-use-the-model-to-classify-an-image">Part 5.2: use the model to classify an image</a></li>
</ul></li>
<li><a href="#links-and-further-work">Links and further work</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#history">History</a></li>
</ul>
</nav>

<p>This is an <a href="http://www.robots.ox.ac.uk/~vgg">Oxford Visual Geometry Group</a> computer vision practical, authored by <a href="http://www.robots.ox.ac.uk/~vedaldi/">Andrea Vedaldi</a> and Andrew Zisserman (Release 2017a), with edits by <a
href="http://www.cs.grinnell.edu/~weinman">Jerod Weinman</a> for <a
href="http://www.cs.grinnell.edu/~weinman/courses/CSC262/2019S">CSC 262-Computer Vision</a>.</p>
<p><img height=400px src="images/cover.png" alt="cover"/></p>
<p><em>Convolutional neural networks</em> are an important class of learnable representations applicable, among others, to numerous computer vision problems. Deep CNNs, in particular, are composed of several layers of processing, each involving linear as well as non-linear operators, that are learned jointly, in an end-to-end manner, to solve particular tasks. These methods are now the dominant approach for feature extraction from audiovisual and textual data.</p>
<p>This lab explores the basics of learning (deep) CNNs. The first part introduces typical CNN building blocks, such as ReLU units and linear filters, with a particular emphasis on understanding back-propagation. The second part looks at learning two basic CNNs. The first network is a simple non-linear filter capturing particular image structures, while the second network recognizes typewritten characters (using a variety of different fonts). These examples illustrate the use of stochastic gradient descent with momentum, the definition of an objective function, the construction of mini-batches of data, and data jittering.</p>
<p>Each part contains several <strong>Questions</strong> (that require pen and paper) and <strong>Tasks</strong> (that require experimentation or coding) to be answered/completed before proceeding further in the lab.</p>
<h2 id="preparation">Preparation</h2>
<p>The MathLAN directory <code>/home/weinman/courses/CSC262/cnn</code> contains the code and other files referenced throughout this lab. After starting Matlab, change to this directory (<em>within</em> Matlab):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb1-1" data-line-number="1">cd /home/weinman/courses/CSC262/cnn</a></code></pre></div>
<h2 id="part1">Part 1: CNN building blocks</h2>
<p>Open the script <code>exercise1.m</code> in the MATLAB editor. it contains commented code and a description for all steps of this exercise, for lab <a href="#part1">Part I</a>. You can cut and paste this code into the MATLAB window to run it, and you may need to modify it as you go through the session.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb2-1" data-line-number="1">edit exercise1.m</a></code></pre></div>
<h3 id="part1.1">Part 1.1: convolution</h3>
<p>A feed-forward neural network can be thought of as the composition of number of functions <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>f</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>‚Ä¶</mi><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>;</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mi>‚Ä¶</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
f(\mathbf{x}) = f_L(\dots f_2(f_1(\mathbf{x};\mathbf{w}_1);\mathbf{w}_2)\dots),\mathbf{w}_{L}).
</annotation></semantics></math> Each function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>l</mi></msub><annotation encoding="application/x-tex">f_l</annotation></semantics></math> takes as input a datum <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>l</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_l</annotation></semantics></math> and a parameter vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>l</mi></msub><annotation encoding="application/x-tex">\mathbf{w}_l</annotation></semantics></math> and produces as output a datum <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\mathbf{x}_{l+1}</annotation></semantics></math>. While the type and sequence of functions is usually handcrafted, the parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mn>1</mn></msub><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{w}=(\mathbf{w}_1,\dots,\mathbf{w}_L)</annotation></semantics></math> are <em>learned from data</em> in order to solve a target problem, for example classifying images or sounds.</p>
<p>In a <em>convolutional neural network</em> data and functions have additional structure. The data <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>1</mn></msub><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{x}_1,\dots,\mathbf{x}_n</annotation></semantics></math> are images, sounds, or more in general maps from a lattice<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> to one or more real numbers. In particular, since the rest of the practical will focus on computer vision applications, data will be 2D arrays of pixels. Formally, each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_i</annotation></semantics></math> will be a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>√ó</mo><mi>N</mi><mo>√ó</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">M \times N \times K</annotation></semantics></math> real array of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>√ó</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M \times N</annotation></semantics></math> pixels and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> channels per pixel. Hence the first two dimensions of the array span space, while the last one spans channels. Note that only the input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>=</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{x}=\mathbf{x}_1</annotation></semantics></math> of the network is an actual image, while the remaining data are intermediate <em>feature maps</em>.</p>
<p>The second property of a CNN is that the functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>l</mi></msub><annotation encoding="application/x-tex">f_l</annotation></semantics></math> have a <em>convolutional structure</em>. This means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>l</mi></msub><annotation encoding="application/x-tex">f_l</annotation></semantics></math> applies to the input map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>l</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_l</annotation></semantics></math> an operator that is <em>local and translation invariant</em>. Examples of convolutional operators are applying a bank of linear filters to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>l</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_l</annotation></semantics></math>.</p>
<p>In this part we will familiarize ourselves with a number of such convolutional and non-linear operators. The first one is the regular <em>linear convolution</em> by a filter bank. We will start by focusing our attention on a single function relation as follows: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mstyle mathvariant="double-struck"><mi>‚Ñù</mi></mstyle><mrow><mi>M</mi><mo>√ó</mo><mi>N</mi><mo>√ó</mo><mi>K</mi></mrow></msup><mo>‚Üí</mo><msup><mstyle mathvariant="double-struck"><mi>‚Ñù</mi></mstyle><mrow><mi>M</mi><mi>‚Ä≤</mi><mo>√ó</mo><mi>N</mi><mi>‚Ä≤</mi><mo>√ó</mo><mi>K</mi><mi>‚Ä≤</mi></mrow></msup><mo>,</mo><mspace width="2.0em"></mspace><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>‚Ü¶</mo><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><mi>.</mi></mrow><annotation encoding="application/x-tex">
 f: \mathbb{R}^{M\times N\times K} \rightarrow \mathbb{R}^{M&#39; \times N&#39; \times K&#39;},
 \qquad \mathbf{x}\mapsto \mathbf{y}.
</annotation></semantics></math> Open the <a href="code/exercise1.m"><code>exercise1.m</code></a> file, select the following part of the code, and execute it in MATLAB (right button &gt; <code>Evaluate selection</code> or <code>F9</code>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">% Read an example image</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">x = imread(<span class="st">&#39;peppers.png&#39;</span>) ;</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">% Convert to single format</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">x = im2single(x) ;</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co">% Visualize the input x</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">figure(<span class="fl">1</span>) ; clf ; imagesc(x) </a></code></pre></div>
<p>This should display an image of bell peppers in Figure 1:</p>
<p><img height=400px src="images/peppers.png" alt="peppers"/></p>
<p>Use MATLAB <code>size</code> command to obtain the size of the array <code>x</code>. Note that the array <code>x</code> is converted to <em>single precision</em> format. This is because the underlying MatConvNet assumes that data is in single precision.</p>
<blockquote>
<p><strong>Question.</strong> The third dimension of <code>x</code> is 3. Why?</p>
</blockquote>
<p>Next, we create a bank of 10 filters of dimension <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>√ó</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">5 \times 5 \times 3</annotation></semantics></math>, initializing their coefficients randomly:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">% Create a bank of linear filters</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">w = randn(<span class="fl">5</span>,<span class="fl">5</span>,<span class="fl">3</span>,<span class="fl">10</span>,<span class="st">&#39;single&#39;</span>) ;</a></code></pre></div>
<p>The filters are in single precision as well. Note that <code>w</code> has four dimensions, packing 10 filters together. Note also that each filter is not flat, but rather a volume containing three slices. The next step is applying the filter to the image. This uses the <code>vl_nnconv</code> function from MatConvNet:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">% Apply the convolution operator</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">y = vl_nnconv(x, w, []) ;</a></code></pre></div>
<p><strong>Remark:</strong> You might have noticed that the third argument to the <code>vl_nnconv</code> function is the empty matrix <code>[]</code>. It can be otherwise used to pass a vector of bias terms to add to the output of each filter.</p>
<p>The variable <code>y</code> contains the output of the convolution. Note that the filters are three-dimensional. This is because they operate on a tensor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> channels. Furthermore, there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>‚Ä≤</mi></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math> such filters, generating a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>‚Ä≤</mi></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math> dimensional map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math> as follows: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mi>‚Ä≤</mi><mi>j</mi><mi>‚Ä≤</mi><mi>k</mi><mi>‚Ä≤</mi></mrow></msub><mo>=</mo><munder><mo>‚àë</mo><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></munder><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi><mi>k</mi><mi>‚Ä≤</mi></mrow></msub><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mi>i</mi><mi>‚Ä≤</mi><mo>,</mo><mi>j</mi><mo>+</mo><mi>j</mi><mi>‚Ä≤</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
y_{i&#39;j&#39;k&#39;} = \sum_{ijk} w_{ijkk&#39;} x_{i+i&#39;,j+j&#39;,k}
</annotation></semantics></math></p>
<blockquote>
<p><strong>Questions:</strong> Study carefully this expression and answer the following:</p>
<ul>
<li>Given that the input map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>√ó</mo><mi>N</mi><mo>√ó</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">M \times N \times K</annotation></semantics></math> dimensions and that each of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>‚Ä≤</mi></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math> filters has dimension <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>f</mi></msub><mo>√ó</mo><msub><mi>N</mi><mi>f</mi></msub><mo>√ó</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">M_f \times N_f \times K</annotation></semantics></math>, what is the dimension of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math>?</li>
<li>Note that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is indexed by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>i</mi><mi>‚Ä≤</mi></mrow><annotation encoding="application/x-tex">i+i&#39;</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>+</mo><mi>j</mi><mi>‚Ä≤</mi></mrow><annotation encoding="application/x-tex">j+j&#39;</annotation></semantics></math>, but that there is no plus sign between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>‚Ä≤</mi></mrow><annotation encoding="application/x-tex">k&#39;</annotation></semantics></math>. Why?</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Task:</strong> Check that the size of the variable <code>y</code> matches your calculations.</p>
</blockquote>
<p>We can now visualise the output <code>y</code> of the convolution. In order to do this, use the <a href="http://www.vlfeat.org/matlab/vl_imarraysc.html"><code>vl_imarraysc</code></a> function to display an image for each feature channel in <code>y</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">% Visualize the output y</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">figure(<span class="fl">2</span>) ; clf ; vl_imarraysc(y) ; colormap gray ;</a></code></pre></div>
<blockquote>
<p><strong>Question:</strong> Study the feature channels obtained. Most will likely contain a strong response in correspondences of edges in the input image <code>x</code>. Recall that <code>w</code> was obtained by drawing random numbers from a Gaussian distribution. Can you explain this phenomenon?</p>
</blockquote>
<p>So far filters preserve the resolution of the input feature map. However, it is often useful to <em>downsample the output</em>. This can be obtained by using the <code>stride</code> option in <code>vl_nnconv</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">% Try again, downsampling the output</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">y_ds = vl_nnconv(x, w, [], <span class="st">&#39;stride&#39;</span>, <span class="fl">16</span>) ;</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">figure(<span class="fl">3</span>) ; clf ; vl_imarraysc(y_ds) ; colormap gray ;</a></code></pre></div>
<p>As you should have noticed in a question above, applying a filter to an image or feature map interacts with the boundaries, making the output map smaller by an amount proportional to the size of the filters. If this is undesirable, then the input array can be padded with zeros by using the <code>pad</code> option:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">% Try padding</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">y_pad = vl_nnconv(x, w, [], <span class="st">&#39;pad&#39;</span>, <span class="fl">4</span>) ;</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">figure(<span class="fl">4</span>) ; clf ; vl_imarraysc(y_pad) ; colormap gray ;</a></code></pre></div>
<blockquote>
<p><strong>Task:</strong> Convince yourself that the previous code‚Äôs output has different boundaries compared to the code that does not use padding. Can you explain the result?</p>
</blockquote>
<p>In order to consolidate what has been learned so far, we will now design a filter by hand:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb9-1" data-line-number="1">w = [<span class="fl">0</span>  <span class="fl">1</span> <span class="fl">0</span> ;</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">     <span class="fl">1</span> -<span class="fl">4</span> <span class="fl">1</span> ;</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">     <span class="fl">0</span>  <span class="fl">1</span> <span class="fl">0</span> ] ;</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">w = single(repmat(w, [<span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">3</span>])) ;</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">y_lap = vl_nnconv(x, w, []) ;</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">figure(<span class="fl">5</span>) ; clf ; colormap gray ;</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">subplot(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">1</span>) ; </a>
<a class="sourceLine" id="cb9-9" data-line-number="9">imagesc(y_lap) ; title(<span class="st">&#39;filter output&#39;</span>) ;</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">subplot(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">2</span>) ;</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">imagesc(-abs(y_lap)) ; title(<span class="st">&#39;- abs(filter output)&#39;</span>) ;</a></code></pre></div>
<blockquote>
<p><strong>Questions:</strong></p>
<ul>
<li>What filter have we implemented?</li>
<li>How are the RGB colour channels processed by this filter?</li>
<li>What image structures are detected?</li>
</ul>
</blockquote>
<h3 id="part1.2">Part 1.2: non-linear activation functions</h3>
<p>As we stated in the introduction, CNNs are obtained by composing several different functions. In addition to the linear filters shown in the <a href="#part1.1">previous part</a>, there are several non-linear operators as well.</p>
<blockquote>
<p><strong>Question:</strong> To gain the primary benefits of a multilayer (deep) network, some of the functions in a CNN <em>must</em> be non-linear. Why?</p>
</blockquote>
<p>The simplest non-linearity is obtained by applying a <em>non-linear activation function</em> after a linear filter; the non-linearity is applied identically to each component (i.e.¬†point-wise) of a feature map. The simplest such function is the <em>Rectified Linear Unit (ReLU)</em>: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub><mo>=</mo><mo>max</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
  y_{ijk} = \max\{0, x_{ijk}\}.
</annotation></semantics></math> This function is implemented by <code>vl_nnrelu</code>; let‚Äôs try this out:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb10-1" data-line-number="1">w = single(repmat([<span class="fl">1</span> <span class="fl">0</span> -<span class="fl">1</span>], [<span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">3</span>])) ;</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">w = cat(<span class="fl">4</span>, w, -w) ;</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">y = vl_nnconv(x, w, []) ;</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">z = vl_nnrelu(y) ;</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">figure(<span class="fl">6</span>) ; clf ; colormap gray ;</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">subplot(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">1</span>) ; vl_imarraysc(y) ;</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">subplot(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">2</span>) ; vl_imarraysc(z) ;</a></code></pre></div>
<blockquote>
<p><strong>Tasks:</strong></p>
<ul>
<li>Run the code above and understand what the filter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math> is doing.</li>
<li>Explain the final result <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math>.</li>
</ul>
</blockquote>
<h3 id="part1.3">Part 1.3: pooling</h3>
<p>There are several other important operators in a CNN. One of them is <em>pooling</em>. A pooling operator operates on individual feature channels, coalescing nearby feature values into one by the application of a suitable operator. Common choices include max-pooling (using the max operator) or sum-pooling (using summation). For example, <em>max-pooling</em> is defined as: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub><mo>=</mo><mo>max</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>y</mi><mrow><mi>i</mi><mi>‚Ä≤</mi><mi>j</mi><mi>‚Ä≤</mi><mi>k</mi></mrow></msub><mo>:</mo><mi>i</mi><mo>‚â§</mo><mi>i</mi><mi>‚Ä≤</mi><mo>&lt;</mo><mi>i</mi><mo>+</mo><mi>p</mi><mo>,</mo><mi>j</mi><mo>‚â§</mo><mi>j</mi><mi>‚Ä≤</mi><mo>&lt;</mo><mi>j</mi><mo>+</mo><mi>p</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">
   y_{ijk} = \max \{ y_{i&#39;j&#39;k} : i \leq i&#39; &lt; i+p, j \leq j&#39; &lt; j + p \}
</annotation></semantics></math> Max pooling is implemented by the <code>vl_nnpool</code> function. Try this now:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb11-1" data-line-number="1">y = vl_nnpool(x, <span class="fl">15</span>) ;</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">figure(<span class="fl">7</span>) ; clf ; imagesc(y) ;</a></code></pre></div>
<blockquote>
<p><strong>Question:</strong> Look at the resulting image. Can you interpret the result?</p>
</blockquote>
<p>The function <code>vl_nnpool</code> supports subsampling and padding just like <code>vl_nnconv</code>. However, for max-pooling feature maps are padded with the value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àí</mo><mi>‚àû</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math> instead of 0. Why?</p>
<h3 id="part1.4">Part 1.4: normalisation</h3>
<p>Another important CNN building block is channel-wise normalisation. This operator normalises the vector of feature channels at each spatial location in the input map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>. The form of the normalization operator is perhaps rather unusual: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∫</mi><mo>+</mo><mi>Œ±</mi><munder><mo>‚àë</mo><mrow><mi>k</mi><mi>‚Ä≤</mi><mo>‚àà</mo><mi>G</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></munder><msubsup><mi>x</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi><mi>‚Ä≤</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>Œ≤</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">
  y_{ijk} = \frac{x_{ijk}}{\left(\kappa + \alpha \sum_{k&#39;\in G(k)}  x_{ijk&#39;}^2\right)^{\beta}}
</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>k</mi><mo>‚àí</mo><mo stretchy="false" form="prefix">‚åä</mo><mfrac><mi>œÅ</mi><mn>2</mn></mfrac><mo stretchy="false" form="postfix">‚åã</mo><mo>,</mo><mi>k</mi><mo>+</mo><mo stretchy="false" form="prefix">‚åà</mo><mfrac><mi>œÅ</mi><mn>2</mn></mfrac><mo stretchy="false" form="postfix">‚åâ</mo><mo stretchy="true" form="postfix">]</mo></mrow><mo>‚à©</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mi>K</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">G(k) = \left[k - \lfloor \frac{\rho}{2} \rfloor, k + \lceil \frac{\rho}{2} \rceil\right] \cap \{1, 2, \dots, K\}</annotation></semantics></math> is a group of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œÅ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math> consecutive feature channels in the input map.</p>
<blockquote>
<p><strong>Task:</strong> Understand what this operator is doing. How would you set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∫</mi><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math> to achieve simple <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>L</mi><mn>2</mn></msup><annotation encoding="application/x-tex">L^2</annotation></semantics></math> normalisation?</p>
</blockquote>
<p>Now let‚Äôs try this out:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb12-1" data-line-number="1">rho = <span class="fl">5</span> ;</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">kappa = <span class="fl">0</span> ;</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">alpha = <span class="fl">1</span> ;</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">beta = <span class="fl">0.5</span> ;</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">y_nrm = vl_nnnormalize(x, [rho kappa alpha beta]) ;</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">figure(<span class="fl">8</span>) ; clf ; imagesc(y_nrm) ;</a></code></pre></div>
<blockquote>
<p><strong>Tasks:</strong></p>
<ul>
<li>Inspect the figure just obtained. Can you interpret it?</li>
<li>Compute the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>L</mi><mn>2</mn></msup><annotation encoding="application/x-tex">L^2</annotation></semantics></math> norm of the feature channels in the output map <code>y_nrm</code>. What do you notice?</li>
<li>Explain this result in relation to the particular choice of the parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œÅ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∫</mi><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>.</li>
</ul>
</blockquote>
<h2 id="part-2-back-propagation-and-derivatives">Part 2: back-propagation and derivatives</h2>
<p>The parameters of a CNN <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mn>1</mn></msub><mo>,</mo><mi>‚Ä¶</mi><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{w}=(\mathbf{w}_1,\dots\mathbf{w}_L)</annotation></semantics></math> should be learned in such a manner that the overall CNN function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{z}= f(\mathbf{x};\mathbf{w})</annotation></semantics></math> achieves a desired goal. In some cases, the goal is to model the distribution of the data, which leads to a <em>generative objective</em>. Here, however, we will use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> as a <em>regressor</em> and obtain it by minimising a <em>discriminative objective</em>. In simple terms, we are given:</p>
<ul>
<li>examples of the desired input-output relations <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>1</mn></msub><mo>,</mo><msub><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>n</mi></msub><mo>,</mo><msub><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{x}_1,\mathbf{z}_1), \dots, (\mathbf{x}_n,\mathbf{z}_n)</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_i</annotation></semantics></math> are input data and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{z}_i</annotation></semantics></math> corresponding output values;</li>
<li>and a loss <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚Ñì</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><mo>,</mo><mover><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><mo accent="true">ÃÇ</mo></mover><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\ell(\mathbf{z},\hat{\mathbf{z}})</annotation></semantics></math> that expresses the penalty for predicting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><mo accent="true">ÃÇ</mo></mover><annotation encoding="application/x-tex">\hat{\mathbf{z}}</annotation></semantics></math> instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math>.</li>
</ul>
<p>We use those to write the empirical loss of the CNN <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> by averaging over the examples: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>‚Ñì</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê≥</mi></mstyle><mi>i</mi></msub><mo>,</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>i</mi></msub><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
L(\mathbf{w}) = \frac{1}{n} \sum_{i=1}^n \ell(\mathbf{z}_i, f(\mathbf{x}_i;\mathbf{w}))
</annotation></semantics></math> Note that the composition of the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> with the loss <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>‚Ñì</mi><annotation encoding="application/x-tex">\ell</annotation></semantics></math> can be though of as a CNN with one more layer (called a <em>loss layer</em>). Hence, with a slight abuse of notation, in the rest of this part we incorporate the loss in the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> (which therefore is a map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí≥</mi></mstyle><mo>‚Üí</mo><mstyle mathvariant="double-struck"><mi>‚Ñù</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathcal{X}\rightarrow\mathbb{R}</annotation></semantics></math>) and do not talk about it explicitly anymore.</p>
<p>The simplest algorithm to minimise <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>, and in fact one that is used in practice, is <em>gradient descent</em>. The idea is simple: compute the gradient of the objective <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> at a current solution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>t</mi></msup><annotation encoding="application/x-tex">\mathbf{w}^t</annotation></semantics></math> and then update the latter along the direction of fastest descent of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>t</mi></msup><mo>‚àí</mo><msub><mi>Œ∑</mi><mi>t</mi></msub><mfrac><mrow><mi>‚àÇ</mi><mi>f</mi></mrow><mrow><mi>‚àÇ</mi><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>t</mi></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
 \mathbf{w}^{t+1} = \mathbf{w}^{t} - \eta_t \frac{\partial f}{\partial \mathbf{w}}(\mathbf{w}^t)
</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∑</mi><mi>t</mi></msub><mo>‚àà</mo><msub><mstyle mathvariant="double-struck"><mi>‚Ñù</mi></mstyle><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">\eta_t \in \mathbb{R}_+</annotation></semantics></math> is the <em>learning rate</em> (sometimes also called the <em>step size</em>)</p>
<h3 id="part-2.1-the-theory-of-back-propagation">Part 2.1: the theory of back-propagation</h3>
<p>Training CNNs is normally done using a gradient-based optimization method. The CNN <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is the composition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> layers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>l</mi></msub><annotation encoding="application/x-tex">f_l</annotation></semantics></math> each with parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>l</mi></msub><annotation encoding="application/x-tex">\mathbf{w}_l</annotation></semantics></math>, which in the simplest case of a chain looks like: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>0</mn></msub><mo>‚Üí</mo><munder><menclose notation="box"><msub><mi>f</mi><mn>1</mn></msub></menclose><munder><mo>‚Üë</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mn>1</mn></msub></munder></munder><mo>‚Üí</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>1</mn></msub><mo>‚Üí</mo><munder><menclose notation="box"><msub><mi>f</mi><mn>2</mn></msub></menclose><munder><mo>‚Üë</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mn>2</mn></msub></munder></munder><mo>‚Üí</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>2</mn></msub><mo>‚Üí</mo><mi>‚Ä¶</mi><mo>‚Üí</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mrow><mi>L</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo>‚Üí</mo><munder><menclose notation="box"><msub><mi>f</mi><mi>L</mi></msub></menclose><munder><mo>‚Üë</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>L</mi></msub></munder></munder><mo>‚Üí</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">
 \mathbf{x}_0
 \longrightarrow
 \underset{\displaystyle\underset{\displaystyle\mathbf{w}_1}{\uparrow}}{\boxed{f_1}}
 \longrightarrow
 \mathbf{x}_1
 \longrightarrow
 \underset{\displaystyle\underset{\displaystyle\mathbf{w}_2}{\uparrow}}{\boxed{f_2}}
 \longrightarrow
 \mathbf{x}_2
 \longrightarrow
 \dots
 \longrightarrow
 \mathbf{x}_{L-1}
 \longrightarrow
 \underset{\displaystyle\underset{\displaystyle\mathbf{w}_L}{\uparrow}}{\boxed{f_L}}
 \longrightarrow
 \mathbf{x}_L
</annotation></semantics></math> During learning, the last layer of the network is the <em>loss function</em> that should be minimized. Hence, the output <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>L</mi></msub><mo>=</mo><msub><mi>x</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{x}_L = x_L</annotation></semantics></math> of the network is a <strong>scalar</strong> quantity (a single number).</p>
<p>The gradient is easily computed using using the <strong>chain rule</strong>. If <em>all</em> network variables and parameters are scalar, this is given by: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><mi>f</mi></mrow><mrow><mi>‚àÇ</mi><msub><mi>w</mi><mi>l</mi></msub></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo>;</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><msub><mi>w</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>f</mi><mi>L</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>x</mi><mrow><mi>L</mi><mo>‚àí</mo><mn>1</mn></mrow></msub></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>L</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo>;</mo><msub><mi>w</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mi>‚ãØ</mi><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>f</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>x</mi><mi>l</mi></msub></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>l</mi></msub><mo>;</mo><msub><mi>w</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>f</mi><mi>l</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>w</mi><mi>l</mi></msub></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>l</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo>;</mo><msub><mi>w</mi><mi>l</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
 \frac{\partial f}{\partial w_l}(x_0;w_1,\dots,w_L)
 =
 \frac{\partial f_L}{\partial x_{L-1}}(x_{L-1};w_L) \times
 \cdots
 \times
 \frac{\partial f_{l+1}}{\partial x_l}(x_l;w_{l+1}) \times
 \frac{\partial f_{l}}{\partial w_l}(x_{l-1};w_l)
</annotation></semantics></math> With tensors, however, there are some complications. Consider for instance the derivative of a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{y}=f(\mathbf{x})</annotation></semantics></math> where both <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> are tensors; this is formed by taking the derivative of each scalar element in the output <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math> with respect to each scalar element in the input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>. If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> has dimensions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>√ó</mo><mi>W</mi><mo>√ó</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">H \times W \times C</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math> has dimensions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>‚Ä≤</mi><mo>√ó</mo><mi>W</mi><mi>‚Ä≤</mi><mo>√ó</mo><mi>C</mi><mi>‚Ä≤</mi></mrow><annotation encoding="application/x-tex">H&#39; \times W&#39; \times C&#39;</annotation></semantics></math>, then the derivative contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>W</mi><mi>C</mi><mi>H</mi><mi>‚Ä≤</mi><mi>W</mi><mi>‚Ä≤</mi><mi>C</mi><mi>‚Ä≤</mi></mrow><annotation encoding="application/x-tex">HWCH&#39;W&#39;C&#39;</annotation></semantics></math> elements, which is often unmanageable (in the order of several GBs of memory for a single derivative).</p>
<p>Note that all intermediate derivatives in the chain rule may be affected by this size explosion except for the derivative of the network output that, being the loss, is a scalar.</p>
<blockquote>
<p><strong>Question:</strong> The output derivatives have the same size as the parameters in the network. Why?</p>
</blockquote>
<p><strong>Back-propagation</strong> allows computing the output derivatives in a memory-efficient manner. To see how, the first step is to generalize the equation above to tensors using a matrix notation. This is done by converting tensors into vectors by using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>vec</mo><annotation encoding="application/x-tex">\operatorname{vec}</annotation></semantics></math> (stacking)<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> operator: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><mi>f</mi></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>l</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><msub><mi>f</mi><mi>L</mi></msub></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>L</mi></msub></mrow></mfrac><mo>√ó</mo><mi>‚ãØ</mi><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><msub><mi>f</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>l</mi></msub></mrow></mfrac><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><msub><mi>f</mi><mi>l</mi></msub></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>l</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
 \frac{\partial \operatorname{vec}f}{\partial \operatorname{vec}^\top \mathbf{w}_l}
 =
 \frac{\partial \operatorname{vec}f_L}{\partial \operatorname{vec}^\top \mathbf{x}_L} \times
 \cdots
 \times
 \frac{\partial \operatorname{vec}f_{l+1}}{\partial \operatorname{vec}^\top \mathbf{x}_l} \times
 \frac{\partial \operatorname{vec}f_{l}}{\partial \operatorname{vec}^\top \mathbf{w}_l}
</annotation></semantics></math> In order to make this computation memory efficient, we <em>project</em> the derivative with respect to a tensor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mi>L</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathbf{p}_L = 1</annotation></semantics></math> as follows: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo>vec</mo><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mi>L</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>‚ä§</mi></msup><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><mi>f</mi></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>l</mi></msub></mrow></mfrac><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mo>vec</mo><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mi>L</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>‚ä§</mi></msup><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><msub><mi>f</mi><mi>L</mi></msub></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>L</mi></msub></mrow></mfrac><mo>√ó</mo><mi>‚ãØ</mi><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><msub><mi>f</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>l</mi></msub></mrow></mfrac><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><msub><mi>f</mi><mi>l</mi></msub></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>l</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
 (\operatorname{vec}\mathbf{p}_L)^\top \times \frac{\partial \operatorname{vec}f}{\partial \operatorname{vec}^\top \mathbf{w}_l}
 =
 (\operatorname{vec}\mathbf{p}_L)^\top
 \times
 \frac{\partial \operatorname{vec}f_L}{\partial \operatorname{vec}^\top \mathbf{x}_L} \times
 \cdots
 \times
 \frac{\partial \operatorname{vec}f_{l+1}}{\partial \operatorname{vec}^\top \mathbf{x}_l} \times
 \frac{\partial \operatorname{vec}f_{l}}{\partial \operatorname{vec}^\top \mathbf{w}_l}
</annotation></semantics></math> Note that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mi>L</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathbf{p}_L=1</annotation></semantics></math> has the same dimension as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>L</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_L</annotation></semantics></math> (the scalar loss) and, being equal to 1, multiplying it to the left of the expression does not change anything. Things are more interesting when products are evaluated from the left to the right, i.e. <em>backward from the output to the input</em> of the CNN. The first such factors is given by: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo>vec</mo><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mrow><mi>L</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>‚ä§</mi></msup><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mo>vec</mo><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mi>L</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>‚ä§</mi></msup><mo>√ó</mo><mfrac><mrow><mi>‚àÇ</mi><mo>vec</mo><msub><mi>f</mi><mi>L</mi></msub></mrow><mrow><mi>‚àÇ</mi><msup><mo>vec</mo><mi>‚ä§</mi></msup><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>L</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
\label{e:factor}
 (\operatorname{vec}\mathbf{p}_{L-1})^\top = (\operatorname{vec}\mathbf{p}_L)^\top
 \times
 \frac{\partial \operatorname{vec}f_L}{\partial \operatorname{vec}^\top \mathbf{x}_L}
\end{equation}</annotation></semantics></math> This results in a new projection vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mrow><mi>L</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\mathbf{p}_{L-1}</annotation></semantics></math>, which can then be multiplied from the left to obtain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mrow><mi>L</mi><mo>‚àí</mo><mn>2</mn></mrow></msub><annotation encoding="application/x-tex">\mathbf{p}_{L-2}</annotation></semantics></math> and so on. The last projection <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mi>l</mi></msub><annotation encoding="application/x-tex">\mathbf{p}_l</annotation></semantics></math> is the desired derivative. Crucially, each projection <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mi>q</mi></msub><annotation encoding="application/x-tex">\mathbf{p}_q</annotation></semantics></math> takes as much memory as the corresponding variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mi>q</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_q</annotation></semantics></math>.</p>
<p>Some might have noticed that, while projections remain small, each factor  does contain one of the large derivatives that we cannot compute explicitly. The trick is that CNN toolboxes contain code that can compute the projected derivatives without explicitly computing this large factor. In particular, for any building block function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{y}=f(\mathbf{x};\mathbf{w})</annotation></semantics></math>, a toolbox such as MatConvNet will implement:</p>
<ul>
<li>A <strong>forward mode</strong> computing the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{y}=f(\mathbf{x};\mathbf{w})</annotation></semantics></math>.</li>
<li>A <strong>backward mode</strong> computing the derivatives of the projected function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">‚ü®</mo><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mo>,</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">‚ü©</mo></mrow><annotation encoding="application/x-tex">\langle \mathbf{p}, f(\mathbf{x};\mathbf{w}) \rangle</annotation></semantics></math> with respect to the input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> and parameter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math>:</li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>‚àÇ</mi><mrow><mi>‚àÇ</mi><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle></mrow></mfrac><mrow><mo stretchy="true" form="prefix">‚ü®</mo><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mo>,</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">‚ü©</mo></mrow><mo>,</mo><mspace width="2.0em"></mspace><mfrac><mi>‚àÇ</mi><mrow><mi>‚àÇ</mi><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle></mrow></mfrac><mrow><mo stretchy="true" form="prefix">‚ü®</mo><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mo>,</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">‚ü©</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\frac{\partial}{\partial \mathbf{x}} \left\langle \mathbf{p}, f(\mathbf{x};\mathbf{w}) \right\rangle,
\qquad
\frac{\partial}{\partial \mathbf{w}} \left\langle \mathbf{p}, f(\mathbf{x};\mathbf{w}) \right\rangle.
</annotation></semantics></math></p>
<p>For example, this is how this looks for the convolution operator:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb13-1" data-line-number="1">y = vl_nnconv(x,w,b) ; <span class="co">% forward mode (get output)</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">p = randn(size(y), <span class="st">&#39;single&#39;</span>) ; <span class="co">% projection tensor (arbitrary)</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">[dx,dw,db] = vl_nnconv(x,w,b,p) ; <span class="co">% backward mode (get projected derivatives)</span></a></code></pre></div>
<p>and this is how it looks for ReLU operator:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb14-1" data-line-number="1">y = vl_nnrelu(x) ;</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">p = randn(size(y), <span class="st">&#39;single&#39;</span>) ;</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">dx = vl_nnrelu(x,p) ;</a></code></pre></div>
<h3 id="part-2.1-using-back-propagation-in-practice">Part 2.1: using back-propagation in practice</h3>
<p>To see how backpropagation is used in practice, focus on a computational block <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, followed by a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>‚Üí</mo><munder><menclose notation="box"><mi>f</mi></menclose><munder><mo>‚Üë</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle></munder></munder><mo>‚Üí</mo><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><mo>‚Üí</mo><menclose notation="box"><mi>g</mi></menclose><mo>‚Üí</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">
 \mathbf{x}
 \longrightarrow 
 \underset{\displaystyle\underset{\displaystyle\mathbf{w}}{\uparrow}}{\boxed{f}} 
 \longrightarrow
 \mathbf{y}
 \longrightarrow 
 \boxed{g}
 \longrightarrow
 z
</annotation></semantics></math> Here <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math> lumps the rest of the network, from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math> to the final scalar output <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>. The goal is to compute the derivatives <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚àÇ</mi><mi>z</mi><mi>/</mi><mi>‚àÇ</mi><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle></mrow><annotation encoding="application/x-tex">\partial z / \partial \mathbf{x}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚àÇ</mi><mi>z</mi><mi>/</mi><mi>‚àÇ</mi><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle></mrow><annotation encoding="application/x-tex">\partial z / \partial \mathbf{w}</annotation></semantics></math> given the derivative <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mo>=</mo><mi>‚àÇ</mi><mi>z</mi><mi>/</mi><mi>‚àÇ</mi><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{p}= \partial z / \partial \mathbf{y}</annotation></semantics></math> of the rest of the network <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>.</p>
<p>Let‚Äôs put this into practice by letting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> be a convolutional layer and by filling <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê©</mi></mstyle><mo>=</mo><mi>‚àÇ</mi><mi>z</mi><mi>/</mi><mi>‚àÇ</mi><mstyle mathvariant="bold"><mi>ùê≤</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{p}= \partial z / \partial \mathbf{y}</annotation></semantics></math> with random values for the sake of the example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">% Read an example image</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">x = im2single(imread(<span class="st">&#39;peppers.png&#39;</span>)) ;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="co">% Create a bank of linear filters and apply them to the image</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">w = randn(<span class="fl">5</span>,<span class="fl">5</span>,<span class="fl">3</span>,<span class="fl">10</span>,<span class="st">&#39;single&#39;</span>) ;</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">y = vl_nnconv(x, w, []) ;</a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="co">% Create the derivative dz/dy</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">dzdy = randn(size(y), <span class="st">&#39;single&#39;</span>) ;</a>
<a class="sourceLine" id="cb15-10" data-line-number="10"></a>
<a class="sourceLine" id="cb15-11" data-line-number="11"><span class="co">% Back-propagation</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">[dzdx, dzdw] = vl_nnconv(x, w, [], dzdy) ;</a></code></pre></div>
<blockquote>
<p><strong>Task:</strong> Run the code above and check the dimensions of <code>dzdx</code> and <code>dzdy</code>. Does this match your expectations?</p>
</blockquote>
<p>An advantage of this modular view is that new building blocks can be coded and added to the architecture in a simple manner. However, it is easy to make mistakes in the calculation of complex derivatives. Hence, it is a good idea to verify results numerically. Consider the following piece of code:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">% Check the derivative numerically</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">ex = randn(size(x), <span class="st">&#39;single&#39;</span>) ;</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">eta = <span class="fl">0.0001</span> ;</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">xp = x + eta * ex  ;</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">yp = vl_nnconv(xp, w, []) ;</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">dzdx_empirical = sum(dzdy(:) .* (yp(:) - y(:)) / eta) ;</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">dzdx_computed = sum(dzdx(:) .* ex(:)) ;</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">fprintf(...</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="st">&#39;der: empirical: %f, computed: %f, error: %.2f %%\n&#39;</span>, ...</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  dzdx_empirical, dzdx_computed, ...</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">  abs(<span class="fl">1</span> - dzdx_empirical/dzdx_computed)*<span class="fl">100</span>) ;</a></code></pre></div>
<blockquote>
<p><strong>Questions:</strong></p>
<ul>
<li>What is the meaning of <code>ex</code> in the code above?</li>
<li>What are the derivatives <code>dzdx_empirical</code> and <code>dzdx_computed</code>?</li>
</ul>
<p><strong>Tasks:</strong></p>
<ul>
<li>Run the code and convince yourself that <code>vl_nnconv</code> derivatives is (probably) correct.</li>
<li>Create a new version of this code to test the derivative calculation with respect to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math>.</li>
</ul>
</blockquote>
<p>We are now ready to build our first elementary CNN, composed of just two layers, and to compute its derivatives:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">% Parameters of the CNN</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">w1 = randn(<span class="fl">5</span>,<span class="fl">5</span>,<span class="fl">3</span>,<span class="fl">10</span>,<span class="st">&#39;single&#39;</span>) ;</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">rho2 = <span class="fl">10</span> ;</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="co">% Run the CNN forward</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">x1 = im2single(imread(<span class="st">&#39;peppers.png&#39;</span>)) ;</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">x2 = vl_nnconv(x1, w1, []) ;</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">x3 = vl_nnpool(x2, rho2) ;</a>
<a class="sourceLine" id="cb17-9" data-line-number="9"></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"><span class="co">% Create the derivative dz/dx3</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">dzdx3 = randn(size(x3), <span class="st">&#39;single&#39;</span>) ;</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13"><span class="co">% Run the CNN backward</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">dzdx2 = vl_nnpool(x2, rho2, dzdx3) ;</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">[dzdx1, dzdw1] = vl_nnconv(x1, w1, [], dzdx2) ;</a></code></pre></div>
<blockquote>
<p><strong>Question:</strong> Note that the last derivative in the CNN is <code>dzdx3</code>. Here, for the sake of the example, this derivative is initialised randomly. In a practical application, what would this derivative represent?</p>
</blockquote>
<p>We can now use the same technique as before to check that the derivative computed through back-propagation are correct.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">% Check the derivative numerically</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">ew1 = randn(size(w1), <span class="st">&#39;single&#39;</span>) ;</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">eta = <span class="fl">0.0001</span> ;</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">w1p = w1 + eta * ew1  ;</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">x1p = x1 ;</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">x2p = vl_nnconv(x1p, w1p, []) ;</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">x3p = vl_nnpool(x2p, rho2) ;</a>
<a class="sourceLine" id="cb18-9" data-line-number="9"></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">dzdw1_empirical = sum(dzdx3(:) .* (x3p(:) - x3(:)) / eta) ;</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">dzdw1_computed = sum(dzdw1(:) .* ew1(:)) ;</a>
<a class="sourceLine" id="cb18-12" data-line-number="12"></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">fprintf(...</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  <span class="st">&#39;der: empirical: %f, computed: %f, error: %.2f %%\n&#39;</span>, ...</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">  dzdw1_empirical, dzdw1_computed, ...</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  abs(<span class="fl">1</span> - dzdw1_empirical/dzdw1_computed)*<span class="fl">100</span>) ;</a></code></pre></div>
<p>If you find a particularly large error here, you may want to remember that this test represents a ‚Äúlinearization‚Äù of the error surface. The random values of either the step sizes (<code>eta * ew1</code>) or the filter weights themselves (<code>w1</code>), may lead to particularly steep error surfaces that are not well approximated by a first-order Taylor series. If that is the case, you may want to re-run the test(s) with different random values.</p>
<h2 id="part-3-learning-a-tiny-cnn">Part 3: learning a tiny CNN</h2>
<p>In this part we will learn a very simple CNN. The CNN is composed of exactly two layers: a convolutional layer and a max-pooling layer: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>2</mn></msub><mo>=</mo><mi>W</mi><mo>*</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>1</mn></msub><mo>+</mo><mi>b</mi><mo>,</mo><mspace width="2.0em"></mspace><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>3</mn></msub><mo>=</mo><msub><mo>maxpool</mo><mi>œÅ</mi></msub><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>2</mn></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathbf{x}_2 = W * \mathbf{x}_1 + b, \qquad \mathbf{x}_3 = \operatorname{maxpool}_\rho \mathbf{x}_2.
</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math> contains a single <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>√ó</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math> square filter, so that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> is a scalar. and the input image <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>=</mo><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{x}=\mathbf{x}_1</annotation></semantics></math> has a single channel.</p>
<blockquote>
<p><strong>Task</strong></p>
<ul>
<li>Open the file <code>tinycnn.m</code> and inspect the code. Convince yourself that the code computes the CNN just described.</li>
<li>Look at the paddings used in the code. If the input image <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>1</mn></msub><annotation encoding="application/x-tex">\mathbf{x}_1</annotation></semantics></math> has dimensions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>√ó</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M\times N</annotation></semantics></math>, what is the dimension of the output feature map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mn>3</mn></msub><annotation encoding="application/x-tex">\mathbf{x}_3</annotation></semantics></math>?</li>
</ul>
</blockquote>
<p>In the rest of the section we will learn the CNN parameters in order to extract blob-like structures from images, such as the ones in the following image:</p>
<p><img width=350px src="images/dots.jpg" alt="Polka dot skirt"/></p>
<h3 id="part-3.1-training-data-and-labels">Part 3.1: training data and labels</h3>
<p>The first step is to load the image <code>data/dots.jpg</code> and to use the supplied <code>extractBlackBlobs</code> function to extract all the black dots in the image.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">% Load an image</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">im = rgb2gray(im2single(imread(<span class="st">&#39;data/dots.jpg&#39;</span>))) ;</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="co">% Compute the location of black blobs in the image</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">[pos,neg] = extractBlackBlobs(im) ;</a></code></pre></div>
<p>The arrays <code>pos</code> and <code>neg</code> contain now pixel labels and will be used as <em>annotations</em> for the supervised training of the CNN. These annotations can be visualised as follows:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb20-1" data-line-number="1">figure(<span class="fl">1</span>) ; clf ; </a>
<a class="sourceLine" id="cb20-2" data-line-number="2">subplot(<span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">1</span>) ; imagesc(im) ; axis equal ; title(<span class="st">&#39;image&#39;</span>) ;</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">subplot(<span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">2</span>) ; imagesc(pos) ; axis equal ; title(<span class="st">&#39;positive points (blob centres)&#39;</span>) ;</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">subplot(<span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">3</span>) ; imagesc(neg) ; axis equal ; title(<span class="st">&#39;negative points (not a blob)&#39;</span>) ;</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">colormap gray ; </a></code></pre></div>
<blockquote>
<p><strong>Task:</strong> Inspect <code>pos</code> and <code>neg</code> and convince yourself that:</p>
<ul>
<li><code>pos</code> contains a single <code>true</code> value in correspondence of each blob centre;</li>
<li><code>neg</code> contains a <code>true</code> value for each pixel sufficiently far away from a blob.</li>
</ul>
<p>Are there pixels for which both <code>pos</code> and <code>neg</code> evaluate to false? Why?</p>
</blockquote>
<h3 id="part-3.2-image-preprocessing">Part 3.2: image preprocessing</h3>
<p>Before we attempt to train the CNN, the image is pre-processed to remove its median value. It is also smoothed by applying a Gaussian kernel of standard deviation 3 pixels:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co">% Pre-smooth the image</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">im = vl_imsmooth(im,<span class="fl">3</span>) ;</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="co">% Subtract median value</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">im = im - median(im(:)) ;</a></code></pre></div>
<p>We will come back to this preprocessing steps later.</p>
<h3 id="part-3.3-learning-with-gradient-descent">Part 3.3: learning with gradient descent</h3>
<p>We will now setup a learning problem to learn <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> to detect black blobs in images. Recall that the CNN computes for each image pixel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math> a score <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo>,</mo><mi>b</mi><msub><mo stretchy="false" form="postfix">)</mo><mrow><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f(\mathbf{x};\mathbf{w},b)_{(u,v)}</annotation></semantics></math>. We would like this score to be:</p>
<ul>
<li>at least as large as 1 for any pixel that is marked as a blob centre (<code>pos</code> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>‚àà</mo><mstyle mathvariant="script"><mi>ùí´</mi></mstyle></mrow><annotation encoding="application/x-tex">(u,v)\in\mathcal{P}</annotation></semantics></math>) and</li>
<li>at most zero for any pixel that is marked as being far away from a blob (<code>neg</code> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>‚àà</mo><mstyle mathvariant="script"><mi>ùí©</mi></mstyle></mrow><annotation encoding="application/x-tex">(u,v)\in\mathcal{N}</annotation></semantics></math>).</li>
</ul>
<p>We do so by defining and then optimising the following objective function: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mi>Œª</mi><mn>2</mn></mfrac><mo stretchy="false" form="prefix">‚à•</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><msup><mo stretchy="false" form="prefix">‚à•</mo><mn>2</mn></msup><mo>+</mo><mfrac><mn>1</mn><mrow><mo stretchy="false" form="prefix">|</mo><mstyle mathvariant="script"><mi>ùí´</mi></mstyle><mo stretchy="false" form="prefix">|</mo></mrow></mfrac><munder><mo>‚àë</mo><mrow><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>‚àà</mo><mstyle mathvariant="script"><mi>ùí´</mi></mstyle></mrow></munder><mo>max</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>‚àí</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo>,</mo><mi>b</mi><msub><mo stretchy="false" form="postfix">)</mo><mrow><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo stretchy="false" form="postfix">}</mo><mo>+</mo><mfrac><mn>1</mn><mrow><mo stretchy="false" form="prefix">|</mo><mstyle mathvariant="script"><mi>ùí©</mi></mstyle><mo stretchy="false" form="prefix">|</mo></mrow></mfrac><munder><mo>‚àë</mo><mrow><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>‚àà</mo><mstyle mathvariant="script"><mi>ùí©</mi></mstyle></mrow></munder><mo>max</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>;</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo>,</mo><mi>b</mi><msub><mo stretchy="false" form="postfix">)</mo><mrow><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
E(\mathbf{w},b) = 
\frac{\lambda}{2}\|\mathbf{w}\|^2
+
\frac{1}{|\mathcal{P}|}\sum_{(u,v) \in \mathcal{P}}
\max\{0, 1 - f(\mathbf{x};\mathbf{w},b)_{(u,v)}\}
+
\frac{1}{|\mathcal{N}|}\sum_{(u,v) \in \mathcal{N}}
\max\{0, f(\mathbf{x};\mathbf{w},b)_{(u,v)}\}.
</annotation></semantics></math></p>
<blockquote>
<p><strong>Questions:</strong></p>
<ul>
<li>What can you say about the score of each pixel if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œª</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda=0</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">E(\mathbf{w},b) =0</annotation></semantics></math>?</li>
<li>Note that the objective enforces a <em>margin</em> between the scores of the positive and negative pixels. How much is this margin?</li>
</ul>
</blockquote>
<p>We can now train the CNN by minimising the objective function with respect to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>. We do so by using an algorithm called <em>gradient descent with momentum</em>. Given the current solution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>t</mi></msub><mo>,</mo><msub><mi>b</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{w}_t,b_t)</annotation></semantics></math>, this is updated to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>b</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{w}_{t+1},b_{t+1})</annotation></semantics></math> by following the direction of fastest descent of the objective <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>t</mi></msub><mo>,</mo><msub><mi>b</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">E(\mathbf{w}_t,b_t)</annotation></semantics></math> as given by the negative gradient <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àí</mo><mi>‚àá</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">-\nabla E</annotation></semantics></math>. However, gradient updates are smoothed by considering a <em>momentum</em> term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mover><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo accent="true">‚Äæ</mo></mover><mi>t</mi></msub><mo>,</mo><msub><mover><mi>Œº</mi><mo accent="true">‚Äæ</mo></mover><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\bar{\mathbf{w}}_{t}, \bar{\mu}_t)</annotation></semantics></math>, yielding the update equations <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo accent="true">‚Äæ</mo></mover><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>‚Üê</mo><mi>Œº</mi><msub><mover><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo accent="true">‚Äæ</mo></mover><mi>t</mi></msub><mo>+</mo><mi>Œ∑</mi><mfrac><mrow><mi>‚àÇ</mi><mi>E</mi></mrow><mrow><mi>‚àÇ</mi><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>t</mi></msub></mrow></mfrac><mo>,</mo><mspace width="2.0em"></mspace><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>‚Üê</mo><msub><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mi>t</mi></msub><mo>‚àí</mo><msub><mover><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><mo accent="true">‚Äæ</mo></mover><mi>t</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
 \bar{\mathbf{w}}_{t+1} \leftarrow \mu \bar{\mathbf{w}}_t + \eta \frac{\partial E}{\partial \mathbf{w}_t},
 \qquad
 \mathbf{w}_{t+1} \leftarrow \mathbf{w}_{t} - \bar{\mathbf{w}}_t.
</annotation></semantics></math> and similarly for the bias term. Here <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œº</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math> is the <em>momentum rate</em> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∑</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math> the <em>learning rate</em>.</p>
<blockquote>
<p><strong>Questions:</strong></p>
<ul>
<li>Explain why the momentum rate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œº</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math> must be smaller than 1. What is the effect of having a momentum rate close to 1?</li>
<li>The learning rate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∑</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math> establishes how fast the algorithm will try to minimise the objective function. Can you see any problem with a large learning rate?</li>
</ul>
</blockquote>
<p>The parameters of the algorithm are set as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb22-1" data-line-number="1">numIterations = <span class="fl">500</span> ;</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">rate = <span class="fl">5</span> ;</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">momentum = <span class="fl">0.9</span> ;</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">shrinkRate = <span class="fl">0.0001</span> ;</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">plotPeriod = <span class="fl">10</span> ;</a></code></pre></div>
<blockquote>
<p><strong>Tasks:</strong></p>
<ul>
<li>Inspect the code in the file <code>exercise3.m</code>. Convince yourself that the code is implementing the algorithm described above. Pay particular attention at the forward and backward passes as well as at how the objective function and its derivatives are computed.</li>
<li>Run the algorithm and observe the results. Then answer the following questions:
<ul>
<li>The learned filter should resemble the discretisation of a well-known differential operator. Which one?</li>
<li>What is the average of the filter values compared to the average of the absolute values?</li>
</ul></li>
<li>Run the algorithm again and observe the evolution of the histograms of the score of the positive and negative pixels in relation to the values 0 and 1. Answer the following:
<ul>
<li>Is the objective function minimised monotonically?</li>
<li>As the histograms evolve, can you identify at least two ‚Äúphases‚Äù in the optimisation?</li>
<li>Once converged, do the score distribute in the manner that you would expect?</li>
</ul></li>
</ul>
<p><strong>Hint:</strong> The <code>plotPeriod</code> option can be changed to plot the diagnostic figure with a higher or lower frequency; this can significantly affect the speed of the algorithm.</p>
</blockquote>
<h3 id="part-3.4-experimenting-with-the-tiny-cnn">Part 3.4: experimenting with the tiny CNN</h3>
<p>In this part we will experiment with several variants of the network just learned. First, we study the effect of the image smoothing:</p>
<blockquote>
<p><strong>Task:</strong> Train again the tiny CNN <em>without smoothing the input image in preprocessing</em>. Answer the following questions:</p>
<ul>
<li>Is the learned filter very different from the one learned before?</li>
<li>If so, can you figure out what ‚Äúwent wrong‚Äù?</li>
<li>Look carefully at the output of the first layer, magnifying with the loupe tool. Is the maximal filter response attained in the middle of each blob?</li>
</ul>
<p><strong>Hint:</strong> The Laplacian of Gaussian operator responds maximally at the centre of a blob only if the latter matches the blob size. Relate this fact to the combination of pre-smoothing the image and applying the learned <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>√ó</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math> filter.</p>
</blockquote>
<p>Now restore the smoothing but switch off subtracting the median from the input image.</p>
<blockquote>
<p><strong>Task:</strong> Train again the tiny CNN <em>without subtracting the median value in preprocessing</em>. Answer the following questions:</p>
<ul>
<li>Does the algorithm converge?</li>
<li>Reduce a hundred-fold the learning rate and increase the maximum number of iterations by an equal amount. Does it get better?</li>
<li>Explain why adding a constant to the input image can have such a dramatic effect on the performance of the optimisation.</li>
</ul>
<p><strong>Hint:</strong> What constraint should the filter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>ùê∞</mi></mstyle><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math> satisfy if the filter output should be zero when (i) the input image is zero or (ii) the input image is a large constant? Do you think that it would be easy for gradient descent to enforce (ii) at all times?</p>
</blockquote>
<p>What you have just witnessed is actually a fairly general principle: centering the data usually makes learning problems much better conditioned.</p>
<p>Now we will explore several parameters in the algorithms:</p>
<blockquote>
<p><strong>Task:</strong> Restore the preprocessing as given in <code>exercise3.m</code>. Try the following:</p>
<ul>
<li>Try increasing the learning rate <code>eta</code>. Can you achieve a better (lower) final value of the energy in the 500 iterations?</li>
<li>Disable momentum by setting <code>momentum = 0</code>. Now try to beat the result obtained above by choosing <code>eta</code>. Can you succeed?</li>
</ul>
</blockquote>
<p>Finally, consider the regularization effect of shrinking:</p>
<blockquote>
<p><strong>Task:</strong> Restore the learning rate and momentum as given in <code>exercise3.m</code>. Then increase the shrinkage factor tenfold, and then a hundred-fold.</p>
<ul>
<li>What is the effect on the convergence speed?</li>
<li>What is the effect on the final value of the total objective function and of the average loss part of it?</li>
</ul>
</blockquote>
<h2 id="part-4-learning-a-character-cnn">Part 4: learning a character CNN</h2>
<p>In this part we will learn a CNN to recognize images of characters.</p>
<h3 id="part-4.1-prepare-the-data">Part 4.1: prepare the data</h3>
<p>Open up <code>exercise4.m</code> and execute Part 4.1. The code loads a structure <code>imdb</code> containing images of the characters <em>a, b, ‚Ä¶, z</em> rendered using approximately 931 fonts downloaded from the <a href="https://www.google.com/fonts">Google Fonts Project</a>. Look at the <code>imdb.images</code> substructure:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb23-1" data-line-number="1">&gt;&gt; imdb.images</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">ans = </a>
<a class="sourceLine" id="cb23-3" data-line-number="3">       id: [<span class="fl">1</span>x29198 double]</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">     data: [<span class="fl">32</span>x32x29198 single]</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    label: [<span class="fl">1</span>x29198 double]</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">      set: [<span class="fl">1</span>x29198 double]</a></code></pre></div>
<p>These are stored as the array <code>imdb.images.id</code> is a 29,198-dimensional vector of numeric IDs for each of the 29,198 character images in the dataset. <code>imdb.images.data</code> contains a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>√ó</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">32 \times 32</annotation></semantics></math> image for each character, stored as a slice of a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>√ó</mo><mn>32</mn><mo>√ó</mo><mn>29</mn><mo>,</mo><mspace width="-0.167em"></mspace><mn>198</mn></mrow><annotation encoding="application/x-tex">32\times 32\times 29,\!198</annotation></semantics></math>-dimensional array. <code>imdb.images.label</code> is a vector of image labels, denoting which one of the 26 possible characters it is. <code>imdb.images.set</code> is equal to 1 for each image that should be used to train the CNN and to 2 for each image that should be used for validation.</p>
<p><img height=400px src="images/chars.png" alt="cover"/></p>
<blockquote>
<p><strong>Task:</strong> Look at the Figure 1 generated by the code and at the code itself and make sure that you understand what you are looking at.</p>
</blockquote>
<h3 id="part-4.2-intialize-a-cnn-architecture">Part 4.2: intialize a CNN architecture</h3>
<p>The function <code>initializeCharacterCNN.m</code> creates a CNN initialised with random weights that will be trained to recognise character images.</p>
<blockquote>
<p><strong>Tasks:</strong></p>
<ol type="1">
<li>By inspecting <code>initializeCharacterCNN.m</code> get a sense of the architecture that will be trained. How many layers are there? How big are the filters?</li>
<li>Use the function <a href="http://www.vlfeat.org/matconvnet/mfiles/simplenn/vl_simplenn_display/"><code>vl_simplenn_display</code></a> to produce a table summarising the architecture.</li>
</ol>
</blockquote>
<p>Note that the <em>penultimate</em> layer has 26 output dimensions, one for each character. Character recognition looks at the maximal output to identify which character is processed by the network.</p>
<p>However, the last network layer is <a href="http://www.vlfeat.org/matconvnet/mfiles/vl_nnsoftmaxloss/"><code>vl_nnsoftmaxloss</code></a>, which in turn is a combination of the <a href="http://www.vlfeat.org/matconvnet/mfiles/vl_nnsoftmax/"><code>vl_nnsoftmax</code></a> function and of the classification log-loss <a href="http://www.vlfeat.org/matconvnet/mfiles/vl_nnloss/"><code>vl_nnloss</code></a>. The <em>softmax</em> operator is given by <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub><mo>=</mo><mfrac><msup><mi>e</mi><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub></msup><mrow><munder><mo>‚àë</mo><msup><mi>k</mi><mi>‚Ä≤</mi></msup></munder><msup><mi>e</mi><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi><msup><mi>k</mi><mi>‚Ä≤</mi></msup></mrow></msub></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">
  y_{ijk} = \frac{e^{x_{ijk}}}{\sum_{k^\prime} e^{x_{ijk^\prime}}}
</annotation></semantics></math> whereas the <em>log-loss</em> is given by <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo>‚àí</mo><mo>log</mo><msub><mi>y</mi><mrow><mi>i</mi><mi>j</mi><msub><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></msub></mrow><annotation encoding="application/x-tex">
  z_{ij} = - \log y_{ij c_{ij}}
</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">c_{ij}</annotation></semantics></math> is the index of the ground-truth class at spatial location <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math>.</p>
<p><strong>Remark:</strong> While in MatConvNet all operators are convolutional, in this case the network is configured such that the output of the classification layer is a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>√ó</mo><mn>1</mn><mo>√ó</mo><mn>26</mn></mrow><annotation encoding="application/x-tex">1 \times 1 \times 26</annotation></semantics></math>-dimensional feature map, i.e.¬†there remains only one spatial location.</p>
<blockquote>
<p><strong>Tasks:</strong></p>
<ol type="1">
<li>Understand what the softmax operator does. <strong>Hint:</strong> to use the log-loss the data must be in the (0, 1] interval.</li>
<li>Understand what is the effect of minimising the log-loss. Which neural response should become larger?</li>
<li>Why do you think MatConvNet provides a third function <code>vl_nnsoftmaxloss</code> combining both functions into a single layer?</li>
</ol>
</blockquote>
<h3 id="part-4.3-train-and-evaluate-the-cnn">Part 4.3: train and evaluate the CNN</h3>
<p>We are now ready to train the CNN. To this end we use the example SGD implementation in MatConvNet (<code>examples/cnn_train.m</code>). This function requires some options:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb24-1" data-line-number="1">trainOpts.batchSize = <span class="fl">100</span> ;</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">trainOpts.numEpochs = <span class="fl">100</span> ;</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">trainOpts.continue = true ;</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">trainOpts.useGpu = false ;</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">trainOpts.learningRate = <span class="fl">0.001</span> ;</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">trainOpts.numEpochs = <span class="fl">15</span> ;</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">trainOpts.expDir = <span class="st">&#39;data/chars-experiment&#39;</span> ;</a></code></pre></div>
<p>This says that the function will operate on SGD mini-batches of 100 elements, it will run for 15 epochs (passes through the data), it will continue from the last epoch if interrupted, if will <em>not</em> use the GPU, it will use a learning rate of 0.001, and it will save any file in the <code>data/chars-experiment</code> subdirectory.</p>
<p>Before the training starts, the average image value is subtracted:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="co">% Take the average image out</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">imageMean = mean(imdb.images.data(:)) ;</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">imdb.images.data = imdb.images.data - imageMean ;</a></code></pre></div>
<p>This is similar to what we have done in Part 3.</p>
<p>The training code is called as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">% Call training function in MatConvNet</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">[net,info] = cnn_train(net, imdb, @getBatch, trainOpts) ;</a></code></pre></div>
<p>Here the key, in addition to the <code>trainOpts</code> structure, is the <code>@getBatch</code> function handle. This is how <code>cnn_train</code> obtains a copy of the data to operate on. Examine this function (see the bottom of the <code>exercise4.m</code> file):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb27-1" data-line-number="1">function [im, labels] = getBatch(imdb, batch)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">im = imdb.images.data(:,:,batch) ;</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">im = <span class="fl">256</span> * reshape(im, <span class="fl">32</span>, <span class="fl">32</span>, <span class="fl">1</span>, []) ;</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">labels = imdb.images.label(<span class="fl">1</span>,batch) ;</a></code></pre></div>
<p>The function extracts the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> images corresponding to the vector of indexes <code>batch</code>. It also reshape them as a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>√ó</mo><mn>32</mn><mo>√ó</mo><mn>1</mn><mo>√ó</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">32\times 32\times 1\times m</annotation></semantics></math> array (as this is the format expected by the MatConvNet functions) and multiplies the values by 256 (the resulting values match the network initialisation and learning parameters). Finally, it also returns a vector of labels, one for each image in the batch.</p>
<blockquote>
<p><strong>Task:</strong> Run the learning code and examine the plots that are produced. As training completes answer the following questions:</p>
<ol type="1">
<li>How many images per second can you process? (Look at the output in the MATLAB screen)</li>
<li>There are two sets of curves: energy and prediction error. What do you think is the difference? What is the ‚Äúenergy‚Äù?</li>
<li>Some curves are labelled ‚Äútrain‚Äù and some other ‚Äúval‚Äù. Should they be equal? Which one should be lower than the other?</li>
<li>Both the top-1 and top-5 prediction errors are plotted. What do they mean? What is the difference?</li>
</ol>
</blockquote>
<p>Once training is finished, the model is saved back:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="co">% Save the result for later use</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">net.layers(end) = [] ;</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">net.imageMean = imageMean ;</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">save(<span class="st">&#39;data/chars-experiment/charscnn.mat&#39;</span>, <span class="st">&#39;-struct&#39;</span>, <span class="st">&#39;net&#39;</span>) ;</a></code></pre></div>
<p>Note that we remember the <code>imageMean</code> for later use. Note also that the softmaxloss layer is <em>removed</em> from the network before saving.</p>
<h3 id="part-4.4-visualise-the-learned-filters">Part 4.4: visualise the learned filters</h3>
<p>The next step is to glance at the filters that have been learned:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb29-1" data-line-number="1">figure(<span class="fl">2</span>) ; clf ; colormap gray ;</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">vl_imarraysc(squeeze(net.layers{<span class="fl">1</span>}.weights{<span class="fl">1</span>}),<span class="st">&#39;spacing&#39;</span>,<span class="fl">2</span>)</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">axis equal ;</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">title(<span class="st">&#39;filters in the first layer&#39;</span>) ;</a></code></pre></div>
<blockquote>
<p><strong>Task:</strong> what can you say about the filters?</p>
</blockquote>
<h3 id="part-4.5-apply-the-model">Part 4.5: apply the model</h3>
<p>We now apply the model to a whole sequence of characters. This is the image <code>data/sentence-lato.png</code>:</p>
<p><img width=576px src="images/sentence-lato.png" alt="sentence-lato"/></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="co">% Load the CNN learned before</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">net = load(<span class="st">&#39;data/chars-experiment/charscnn.mat&#39;</span>) ;</a>
<a class="sourceLine" id="cb30-3" data-line-number="3"></a>
<a class="sourceLine" id="cb30-4" data-line-number="4"><span class="co">% Load the sentence</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5">im = im2single(imread(<span class="st">&#39;data/sentence-lato.png&#39;</span>)) ;</a>
<a class="sourceLine" id="cb30-6" data-line-number="6">im = <span class="fl">256</span> * (im - net.imageMean) ;</a>
<a class="sourceLine" id="cb30-7" data-line-number="7"></a>
<a class="sourceLine" id="cb30-8" data-line-number="8"><span class="co">% Apply the CNN to the larger image</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">res = vl_simplenn(net, im) ;</a></code></pre></div>
<blockquote>
<p><strong>Question:</strong> The image is much wider than 32 pixels. Why can you apply to it the CNN learned before for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>√ó</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">32\times 32</annotation></semantics></math> patches?</p>
</blockquote>
<blockquote>
<p><strong>Task:</strong> examine the size of the CNN output using <code>size(res(end).x)</code>. Does this match your expectation?</p>
</blockquote>
<p>Now use the <code>decodeCharacters()</code> function to visualise the results:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co">% Visualize the results</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">figure(<span class="fl">3</span>) ; clf ;</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">decodeCharacters(net, imdb, im, res) ;</a></code></pre></div>
<blockquote>
<p><strong>Tasks:</strong> inspect the output of the <code>decodeCharacters()</code> function and answer the following:</p>
<ol type="1">
<li>Is the quality of the recognition any good?</li>
<li>Does this match your expectation given the recognition rate in your validation set (as reported by <code>cnn_train</code> during training)?</li>
</ol>
</blockquote>
<h3 id="part-4.6-training-with-jitter">Part 4.6: training with jitter</h3>
<p>A key issue with the previous CNN is that it is not trained to recognise characters in the context of other characters. Furthermore, characters are perfectly centred in the patch. We can relax these assumptions by making the training data ‚Äúmore realistic‚Äù. In this part we will train a second network applying <em>data jittering</em> by:</p>
<ol type="1">
<li>Randomly adding a character to the left and to the right of the one recognised and</li>
<li>Randomly shifting the characters by up to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>¬±</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\pm 5</annotation></semantics></math> pixels horizontally and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>¬±</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\pm 2</annotation></semantics></math> pixels vertically.</li>
</ol>
<p>This is implemented by the <code>getBatchWithJitter()</code> function (note that jittering is applied on the fly as it is so fast).</p>
<blockquote>
<p><strong>Tasks:</strong></p>
<ol type="1">
<li>Train a second model, using the jittered data.</li>
<li>Look at the training and validation errors. Is their gap as wide as it was before?</li>
<li>Use the new model to recognise the characters in the sentence by repeating the previous part. Does it work better?</li>
<li><strong>Advanced.</strong> What else can you change to make the performance even better?</li>
</ol>
</blockquote>
<h3 id="part-4.7-training-using-the-gpu">Part 4.7: Training using the GPU</h3>
<blockquote>
<p>Skip this part if you do not wish to experiment training using GPU hardware.</p>
</blockquote>
<p>A key challenge in deep learning is the sheer amount of computation required to train gigantic models from equally gigantic data collections. State-of-the-art vision models, for example, take weeks to train on specialised hardware such as GPUs, and they are essentially untrainable on CPU (unless you have access to a very large cluster). Thus it is practically important to learn how to use this hardware.</p>
<p>In MatConvNet this is almost trivial as it builds on the easy-to-use GPU support in MATLAB. You can follow this list of steps to try it out:</p>
<ol type="1">
<li>Clear the models generated and cached in the previous steps. To do this, rename or delete the directories <code>data/characters-experiment</code> and <code>data/characters-jit-experiment</code>.</li>
<li>Make sure that MatConvNet is compiled with GPU support. To do this, use <code>setup('useGpu', true)</code>.</li>
<li>Try again training the model of <code>exercise4.m</code> switching to <code>true</code> the <code>useGpu</code> flag.</li>
</ol>
<blockquote>
<p><strong>Task:</strong> Follow the steps above and note the speed of training. How many images per second can you process now?</p>
</blockquote>
<p>For these small images, the GPU speedup is probably modest (perhaps 2-5 fold). However, for larger models it becomes really dramatic (&gt;10 fold).</p>
<h2 id="part-5-using-pretrained-models">Part 5: using pretrained models</h2>
<p>A characteristic of deep learning is that it constructs <em>representations</em> of the data. These representations tend to have a universal value, or at least to be applicable to an array of problems that transcends the particular task a model was trained for. This is fortunate as training complex models requires weeks of works on one or more GPUs or hundreds of CPUs; these models can then be frozen and reused for a number of additional applications, with no or minimal additional work.</p>
<p>In this part we will see how MatConvNet can be used to download and run high-performance CNN models for image classification. These models are trained from 1.2M images in the ImageNet datasets to discriminate 1,000 different object categories.</p>
<p>Several <a href="http://www.vlfeat.org/matconvnet/pretrained/">pertained models</a> can be downloaded from the MatConvNet website, including several trained using other CNN implementations such as Caffe. One such models is included in the practical <code>data/imagenet-vgg-verydeep-16.mat</code> file. This is one of the best models from the ImageNet ILSVCR Challenge 2014.</p>
<h3 id="part-5.1-load-a-pre-trained-model">Part 5.1: load a pre-trained model</h3>
<p>The first step is to load the model itself. This is in the format of the <code>vl_simplenn</code> CNN wrapper, and ships as a MATLAB <code>.mat</code> file:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb32-1" data-line-number="1">net = load(<span class="st">&#39;data/imagenet-vgg-verydeep-16.mat&#39;</span>) ;</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">vl_simplenn_display(net) ;</a></code></pre></div>
<blockquote>
<p><strong>Tasks:</strong></p>
<ol type="1">
<li>Look at the output of <code>vl_simplenn_display</code> and understand the structure of the model. Can you understand why it is called ‚Äúvery deep‚Äù?</li>
<li>Look at the size of the file <code>data/imagenet-vgg-verydeep-16.mat</code> on disk. This is <em>just the model</em>.</li>
</ol>
</blockquote>
<h3 id="part-5.2-use-the-model-to-classify-an-image">Part 5.2: use the model to classify an image</h3>
<p>We can now use the model to classify an image. We start from <code>peppers.png</code>, a MATLAB stock image:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="co">% obtain and preprocess an image</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">im = imread(<span class="st">&#39;peppers.png&#39;</span>) ;</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">im_ = single(im) ; <span class="co">% note: 255 range</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">im_ = imresize(im_, net.normalization.imageSize(<span class="fl">1</span>:<span class="fl">2</span>)) ;</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">im_ = im_ - net.normalization.averageImage ;</a></code></pre></div>
<p>The code normalises the image in a format compatible with the model <code>net</code>. This amounts to: converting the image to <code>single</code> format (but with range 0,‚Ä¶,255 rather than [0, 1] as typical in MATLAB), resizing the image to a fixed size, and then subtracting an average image.</p>
<p>It is now possible to call the CNN:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="co">% run the CNN</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">res = vl_simplenn(net, im_) ;</a></code></pre></div>
<p>As usual, <code>res</code> contains the results of the computation, including all intermediate layers. The last one can be used to perform the classification:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="co">% show the classification result</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">scores = squeeze(gather(res(end).x)) ;</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">[bestScore, best] = max(scores) ;</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"></a>
<a class="sourceLine" id="cb35-5" data-line-number="5">figure(<span class="fl">1</span>) ; clf ; imagesc(im) ;</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">title(sprintf(<span class="st">&#39;%s (%d), score %.3f&#39;</span>,...</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">  net.classes.description{best}, best, bestScore)) ;</a></code></pre></div>
<p>That completes this practical.</p>
<h2 id="links-and-further-work">Links and further work</h2>
<ul>
<li>The code for this practical is written using the software package <a href="http://www.vlfeat.org/matconvnet">MatConvNet</a>. This is a software library written in MATLAB, C++, and CUDA and is freely available as source code and binary.</li>
<li>The ImageNet model is the <em>VGG very deep 16</em> of Karen Simonyan and Andrew Zisserman.</li>
</ul>
<h2 id="acknowledgements">Acknowledgements</h2>
<ul>
<li>Beta testing by: Karel Lenc and Carlos Arteta.</li>
<li>Bugfixes/typos by: Sun Yushi.</li>
</ul>
<h2 id="history">History</h2>
<ul>
<li>Used in the Oxford AIMS CDT, 2016-17.</li>
<li>Used in the Oxford AIMS CDT, 2015-16.</li>
<li>Used in the Oxford AIMS CDT, 2014-15.</li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A two-dimensional <em>lattice</em> is a discrete grid embedded in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>R</mi><mn>2</mn></msup><annotation encoding="application/x-tex">R^2</annotation></semantics></math>, similar for example to a checkerboard.<a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
<li id="fn2"><p>The stacking of a tensor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>‚àà</mo><msup><mstyle mathvariant="double-struck"><mi>‚Ñù</mi></mstyle><mrow><mi>H</mi><mo>√ó</mo><mi>W</mi><mo>√ó</mo><mi>C</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{x}\in\mathbb{R}^{H\times W\times C}</annotation></semantics></math> is the vector <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>vec</mo><mstyle mathvariant="bold"><mi>ùê±</mi></mstyle><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>x</mi><mn>111</mn></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>x</mi><mn>211</mn></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>‚ãÆ</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>x</mi><mrow><mi>H</mi><mn>11</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>x</mi><mn>121</mn></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>‚ãÆ</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>x</mi><mrow><mi>H</mi><mi>W</mi><mi>C</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex"> \operatorname{vec}\mathbf{x}= \begin{bmatrix} x_{111}\\ x_{211} \\ \vdots \\ x_{H11} \\ x_{121} \\\vdots \\ x_{HWC} \end{bmatrix}.</annotation></semantics></math><a href="#fnref2" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
</body>
</html>
